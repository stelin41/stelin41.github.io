<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>android on stelin41</title><link>https://stelin41.github.io/es/tags/android/</link><description>Recent content in android on stelin41</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2022 stelin41</copyright><lastBuildDate>Fri, 25 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://stelin41.github.io/es/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Laser Trainer Pro</title><link>https://stelin41.github.io/es/posts/laser_trainer_pro/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://stelin41.github.io/es/posts/laser_trainer_pro/</guid><description>Introducción Este es el segundo proyecto que he llegado a publicar. Es una aplicación de deportes para practicar la puntería desde casa. Sin duda este proyecto fué mucho más difícil e interesante de desarrollar que Flying Poo, el anterior que hice. Lo publiqué en 2021 y tardé unos dos meses para desarrollarlo.
Tráiler:
El desarrollo Exceptuando unas cinco líneas de código que hicieron falta para hacer que la cámara funcionase correctamente en IOS, todo está programado en Python usando un framework multiplataforma llamado Kivy.</description><content>&lt;h1 id="introducción">Introducción&lt;/h1>
&lt;p>Este es el segundo proyecto que he llegado a publicar. Es una aplicación de deportes para practicar la puntería desde casa. Sin duda este proyecto fué mucho más difícil e interesante de desarrollar que &lt;a href="https://stelin41.github.io/es/posts/flying_poo">Flying Poo&lt;/a>, el anterior que hice. Lo publiqué en 2021 y tardé unos dos meses para desarrollarlo.&lt;/p>
&lt;p>Tráiler:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/yQjpZzEaq-s" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h1 id="el-desarrollo">El desarrollo&lt;/h1>
&lt;p>Exceptuando unas cinco líneas de código que hicieron falta para hacer que la cámara funcionase correctamente en IOS, todo está programado en Python usando un framework multiplataforma llamado Kivy. Lo hice así por dos razones: la primera es para acostumbrarme más a programar en Python, y la segunda es para no tener que reimplementar el mismo código para cada plataforma.&lt;/p>
&lt;p>A primera vista, el principal reto para crear este programa es conseguir detectar la posición del láser. De hecho, esta fué una parte bastante divertida. Al principio pensé que usar redes neuronales podría ser una buena solución, pero acabé teniendo una mejor idea. Primero hice una gravación de prueba, donde aparecen diferentes disparos del láser, y luego usé la librería de OpenCV (aunque más tarde tuve que cambiarla por Numpy, porque no hay una receta que lo compile para IOS) para experimentar con varias ideas.&lt;/p>
&lt;p>Tras muchos experimentos y pruebas se me ocurrió calcular la diferencia entre los píxeles del fotograma actual y el anterior, y funcionó sorprendentemente bien. Aparecía algo de ruido, pero se solucionó al filtrar los píxeles que variaban menos. Luego solo fué jugar un poco con los parámetros para mejorar los resultados. Aunque en condiciones de alta luminosidad el láser apenas destaca entre el ruido causado por la luz ambiental, por lo que tuve que implementar una función que detecta si este es el caso y avise al usuario. Decidí usar solo una de las capas RGB para ahorrar recursos y descubrí que el canal verde es el que detecta el láser más limpiamente (algo que me pareció curioso, ya que el láser que usé para las pruebas es rojo). Para calcular la puntuación, apliqué una máscara para saber dentro de qué anillo impactó el láser.&lt;/p>
&lt;h1 id="los-problemas">Los problemas&lt;/h1>
&lt;p>Después vino la parte algo menos entretenida: llevarlo a una aplicación real. Esta parte no tiene mucho misterio, y como la mayoría de proyectos de desarrollo de software se podría resumir en tres pasos: decidir cuál será el siguiente paso; googlear cómo hacer X; buscar porqué no funciona Z; y repetir. Este método funciona siempre y cuando alguien haya tenido un problema parecido antes o exista algún tipo de documentación. Dada la reducida comunidad que tiene Kivy, es de esperar que aparezcan problemas nunca planteados, pero cuando ni siquiera hay documentación que esté relacionada, esto se vuelve un verdadero problema.&lt;/p>
&lt;p>Al intentar migrar el código a IOS, resultó que ya no podía acceder al buffer de la cámara para poder manipular la imágen. Como nada de esto está documentado, mi única opción era leer el código fuente de Kivy, y resulta que en la implementación de Kivy para IOS el código que usaba para acceder al buffer era inexistente, y no tengo conocimientos suficientes sobre IOS como para poder implementarlo por mí mismo. Mientras leía el código me daba cuenta de que mis opciones se reducían cada vez más, y empecé a entrar en desesperación. Pedir ayuda podría no ser una opción, ya que nadie ha sido capaz de capturar el buffer de la cámara en IOS&amp;hellip; ¿o tal vez sí? Ahí es donde entra mi salvación: &lt;a href="https://github.com/kivy-garden/zbarcam">zbarcam&lt;/a>, un escáner de códigos de barra y QRs.&lt;/p>
&lt;p>Al parecer los desarrolladores de este paquete fueron los únicos que, usando Kivy, han sido capaces de acceder al buffer de la cámara desde IOS. Para facilitar el proceso y no tener que modificar el código fuente directamente, opté por importarlo y usar la magia de la POO para heredar las características de cualquier clase y poder modificar sus funciones a gusto.&lt;/p>
&lt;h1 id="resultados">Resultados&lt;/h1>
&lt;p>Gracias a este proyecto, pulí mis habilidades con Python y tuve una primera degustación de cómo es la investigación en el área de la computación, y resultó ser bastante divertido. Eso sí, me he saltado muchos problemas que tuve en este resumen, como usar las APIs de Android e IOS desde Python para poder imprimir la diana, o corregir la orientación de la cámara en IOS accediendo a la API del giroscopio y medir la inclinación (porque por algún motivo IOS gira por defecto la imágen en función de la orientación del teléfono, y no pude encontrar ninguna forma de desactivarlo con Kivy).&lt;/p>
&lt;p>Dejo por aquí los enlaces a &lt;a href="https://play.google.com/store/apps/details?id=com.payday444.lasertrainerpro&amp;amp;hl=es&amp;amp;gl=ES">Google Play&lt;/a> y a la &lt;a href="https://apps.apple.com/es/app/laser-trainer-pro/id1579891923">App Store&lt;/a> por si le interesa a alguien.&lt;/p></content></item><item><title>Flying Poo</title><link>https://stelin41.github.io/es/posts/flying_poo/</link><pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate><guid>https://stelin41.github.io/es/posts/flying_poo/</guid><description>Presentación Flying Poo es un videojuego para android que desarrollé entre 2018-19, y en este artículo voy a contar cómo fué su desarrollo y qué aprendí de ello.
Este es su tráiler:
El principio del desarrollo El intel pentium con gráficos integrados y los 4GB de RAM que tenía no podrían ni instalar el motor de juegos, así que necesitava un nuevo equipo. Recuerdo que poco antes de que empezar a cursar 3º de la ESO construí un PC por partes, y estuve mucho tiempo investigando sobre el funcionamiento de cada una.</description><content>&lt;h1 id="presentación">Presentación&lt;/h1>
&lt;p>&lt;a href="https://play.google.com/store/apps/details?id=com.PayDay444.Flying_Poo&amp;amp;hl=es">Flying Poo&lt;/a> es un videojuego para android que desarrollé entre 2018-19, y en este artículo voy a contar cómo fué su desarrollo y qué aprendí de ello.&lt;/p>
&lt;p>Este es su tráiler:&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube-nocookie.com/embed/JWMPL8vwo5U" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h1 id="el-principio-del-desarrollo">El principio del desarrollo&lt;/h1>
&lt;p>El intel pentium con gráficos integrados y los 4GB de RAM que tenía no podrían ni instalar el motor de juegos, así que necesitava un nuevo equipo. Recuerdo que poco antes de que empezar a cursar 3º de la ESO construí un PC por partes, y estuve mucho tiempo investigando sobre el funcionamiento de cada una. Todavía uso el mismo equipo, que al fin y al cabo no hubiera conseguido si no fuera por mi padre :)&lt;/p>
&lt;p>En la parte técnica, realmente no hay mucho que destacar. Fué creado con Unreal Engine 4 y programado usando blueprints. El tiempo de desarrollo, desde su inicio hasta su publicación, fué de 13 meses. Los modelos 3D fueron hechos en 3ds Max, las interfaz y texturas dibujadas con Photoshop y los audios editados en Audacity. Como es de esperar, hubieron muchos problemas técnicos (la mayoría causados por bugs en Unreal Engine). Aun así ninguno necesitó de conocimientos de informática avanzada. Incluso recuerdo que, entre los problemas que no eran culpa del motor, uno de los que más me costó fué calcular el ángulo en el que las personas tienen que lanzar los objetos a la gaviota. No sabía casi nada de trigonometría, pero al final pude apañármelas. Es casi gracioso recordarlo.&lt;/p>
&lt;figure class="center" >
&lt;img src="https://stelin41.github.io/img/flying_poo_arrow.png" alt="flying poo arrow" style="border-radius: 8px;" />
&lt;figcaption class="center" style="border-radius: 8px;" >Captura de pantalla dentro de UE4&lt;/figcaption>
&lt;/figure>
&lt;h1 id="lecciones-aprendidas">Lecciones aprendidas&lt;/h1>
&lt;p>De hecho, es justamente por no necesitar de conocimientos avanzados que considero que lo que más aprendí no fué en la parte técnica, sino que en lo que realmente sigifica llevar todo eso a cabo. Muchos pensarían que es una locura dedicarle 13 meses para un primer juego/programa que uno desarrolla. Aunque es cierto que probablemente hubiera aprendido prácticamente lo mismo si le hubiera dedicado 3 meses, nunca me habría dado cuenta lo que significa hacer un proyecto de esta magnitud. Dedicarle una parte significativa de mi tiempo libre realmente impactó en mi crecimiento como persona al darme cuenta de lo que significa trabajar. Aunque no se acerca a la vida de un adulto, fué más que suficiente para que me hiciera una idea de cómo es.&lt;/p>
&lt;h1 id="la-mayoría-de-los-videojuegos-son-manipuladores">La mayoría de los videojuegos son manipuladores&lt;/h1>
&lt;p>Otra cosa que destacó fué que finalmente me dí cuenta de cómo es el mundo del desarrollo de videojuegos. Lo principal que aprendí fué que un escritor y un psicólogo serían capaces de hacer un videojuego diez veces mejor que un programador profesional. Crear un videojuego se parece mucho más al arte o la escritura a lo que se definiría como programación. Crear un videojuego es crear un universo a parte. Uno debe pensar en cómo es su lógica y su funcionamiento al completo, de manera que sea entretenido, al igual que un libro. Estaría genial si eso fuera todo, pero hoy en día hacer un buen videojuego no es suficiente. Ahí es donde entra el psicólogo, y tendría dos objetivos: atraer gente al juego y conseguir hacer dinero con ello. Eso no parece algo tan malo, ¿verdad?&lt;/p>
&lt;p>La verdadera pregunta es porqué un psicólogo es el mejor para hacer este trabajo. Actualmente existen dos modelos principales para monetizar un videojuego, aunque en algunos casos se emplea una mezcla de los dos. El primero es venderlo, y para ello se debe usar todas las técnicas posibles para atraer jugadores, ya sea por que se ve &amp;ldquo;bonito&amp;rdquo; o por que tenga alguna característica que atraiga la primera impresión de los jugadores, como el caso de &lt;strong>No Man&amp;rsquo;s Sky&lt;/strong>. Este es el modelo más clásico y menos dañino a la salud de los jugadores, pero se ha descubierto que en la mayoría de casos, el modelo de freeware es mucho más rentable. Este modelo se caracteriza por facilitar la atracción de jugadores al poner el juego gratis. Pero luego, los psicólogos buscan mil maneras para hacer el juego lo suficientemente adictivo como para que los jugadores quieran comprar artículos o expansiones dentro del juego. Algunos de los métodos que usan son las recompensas diarias o las notificaciones. Siempre buscan que los jugadores no se aburran para que sigan jugando, pero de manera que nunca lleguen a estar satisfechos y así quieran comprar extras para intentar &amp;ldquo;saciarse&amp;rdquo;.&lt;/p>
&lt;figure class="center" >
&lt;img src="https://stelin41.github.io/img/no_mans_sky_logo.png" alt="no mans sky logo" style="border-radius: 8px;" />
&lt;figcaption class="center" style="border-radius: 8px;" >&lt;a href='https://www.nomanssky.com/press/'>La portada de No Man's Sky&lt;/a>&lt;/figcaption>
&lt;/figure>
&lt;p>Por otra parte, ¿alguna vez te has preguntado porqué los casinos usan sus propias fichas en vez de dinero? Esto es para que no parezca que estás usando dinero real, y que tan solo parezca un simple &amp;ldquo;juego&amp;rdquo;. Con esto se consigue disminuir las probabilidades de que uno piense dos veces antes de apostar. Y hay muchos videojuegos que usan esta misma técnica con el mismo propósito de que no parezca que están quemando dinero.&lt;/p>
&lt;h1 id="conclusión">Conclusión&lt;/h1>
&lt;p>Cuando me dí cuenta de todo esto, empecé a jugar mucho menos y con el paso del tiempo hizo que me interesara por otros mundos de la informática: sistemas operativos, especialmente linux; redes y sistemas de comunicación; inteligencia artificial; ciberseguridad; e incluso el mundo de las inversiones.&lt;/p>
&lt;p>En resumen, desarrollar este videojuego realmente cambió mi perspectiva del mundo del desarrollo del software y del desarrollo de videojuegos. Finalmente entendí cómo los videojuegos buscan manipular a las personas para conseguir beneficios, a costa de su salud. También interioricé grán parte de la lógica detrás de la programación en general. Aprendí lo que significa estar en frente de una pantalla tanto tiempo y lo importante que es la motivación y la salud mental cuando uno lo hace todo por su cuenta, especialmente a la hora de dedicarle tanto tiempo a un proyecto. También me dí cuenta de la importancia de divertirse con estos proyectos. Además, ¿no es increíble pensar en pensar en todo lo que puede crear con la tecnología que disponemos?, y ¿lo apasionante que puede llegar a ser el futuro?&lt;/p></content></item></channel></rss>